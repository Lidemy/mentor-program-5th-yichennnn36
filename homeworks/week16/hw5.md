## 這週學了一大堆以前搞不懂的東西，你有變得更懂了嗎？請寫下你的心得。
這週真的學了好多非常重要的觀念知識，起初把教材看完時，又花了快兩倍的時間重新複習，一直都是抱持著，「看一次不懂，搭配實作和重看非常多次總會懂了吧！」的想法回頭去讀、吸收。

想想一開始連變數是 primitive type 是什麼都有點失憶，更不用說什麼是 call by value、call by reference、call by sharing。讀完胡立大大的好文後，知道了名詞定義上的差異之外，重點是要搞清楚參數在操作的時候會有怎樣的行為。也重新釐清了記憶體指向的觀念。

以往在面對作用域的問題時都有蠻大的不確定性，例如下面的程式碼：
```javascript
function test() {
  var a = 1
  inner()
  function inner() {
    console.log(a)
  }
}
test()
```

大概知道會 log 出 1，但不是很了解程式碼實際上的運作模式和原理，所以總是會有點對自己的答案感到懷疑。不過讀完教材弄清楚後，scope 作用域就是一個「變數的生存範圍，一旦出了這個範圍，就無法存取到這個變數」。以及 hoisting，讓變數宣告和函式「提升」，而 hoisting 是怎麼運作的在作業中也做了蠻多的複習。

作用域又有「靜態作用域」和「動態作用域」，靜態作用域則表示：在 function 被「宣告」的時候就已經決定好，並非是 function 被「執行」時。而 JS 的作用域是採用靜態作用域。
如果在作用域裡面找不到，則會往上一層來尋找，而形成一個「scope chain 作用域鏈」。

以此為例：
```javascript
var arr = [];
for (var i = 0; i < 5; i++) {
	arr[i] = function() {
		console.log(i);
	}
}
arr[0](); // 5
arr[1](); // 5
```

再過去幾週的課程裡就有提過此的概念，原本以為輸出會是 0 -> 1 -> 2...以此類推，殊不知結果都是 5，當下使用 `let` 將迴圈改寫後可以順利執行，不過因為那時作用域、block scope以及閉包的觀念都不是很了解，藉由這禮拜的課程又補齊了觀念，知道兩者使用上的差異為何，因為 `let` 的特性，讓迴圈每跑一圈都產生一個新的作用域；而此例子中，會建立：

```
arr[0] = function() {
		console.log(i);
	}

arr[1] = function() {
		console.log(i);
	}

... // 以此類推
```

然後執行 `arr[0]`， i 的值在 function 裡找不到就會往上一層 scope 去找，因此找到全域變數，迴圈跑完 i = 5 結束跳出，因此才會 log 出 5。
也可以利用閉包概念，function 裡 return function ，把 i 值傳進去。


而本週我覺得學習到很重要的一點是許多觀念都可以從規格書上來找答案，自己有稍微努力看了一下挑戰題和進階挑戰題的文章和文件，沒有看完，我自己覺得蠻吃力的，對於裡面一些專有名詞的使用以及到底在講什麼都理解的有待加強，希望學習到後面再回頭來看時會有更多的進展和理解。